<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>gooey morphing slime blobs</title>
<style>
  html, body {
    margin: 0; padding: 0; height: 100%; width: 100%;
    overflow: hidden;
    cursor: default;
    background: black;
  }
  body {
    position: relative;
  }
  canvas#bgCanvas {
    position: fixed;
    top: 0; left: 0;
    width: 100vw; height: 100vh;
    pointer-events: none;
    z-index: 0;
  }
  .blob {
    position: absolute;
    border-radius: 50%;
    filter: blur(70px);
    will-change: transform, border-radius, background-color;
    cursor: pointer;
    opacity: 0.14;
    transition: background-color 0.5s ease;
    mix-blend-mode: screen;
    z-index: 1;
    background: radial-gradient(circle at center, rgba(255,255,255,0.12), transparent 70%);
    backdrop-filter: blur(10px);
  }
</style>
</head>
<body>

<canvas id="bgCanvas"></canvas>

<div class="blob" style="width: 700px; height: 700px;"></div>
<div class="blob" style="width: 600px; height: 600px;"></div>
<div class="blob" style="width: 500px; height: 500px;"></div>
<div class="blob" style="width: 450px; height: 450px;"></div>
<div class="blob" style="width: 350px; height: 350px;"></div>

<script>
  const blobs = [...document.querySelectorAll('.blob')];
  const maxDist = 350;

  // utility for random color and smooth color lerp
  function randomRGBA() {
    return {
      r: 30 + Math.random() * 180 | 0,
      g: 60 + Math.random() * 150 | 0,
      b: 90 + Math.random() * 120 | 0,
      a: 0.18
    };
  }
  function rgbaToString(c) {
    return `rgba(${c.r},${c.g},${c.b},${c.a})`;
  }
  function lerpColor(a, b, t) {
    return {
      r: a.r + (b.r - a.r) * t,
      g: a.g + (b.g - a.g) * t,
      b: a.b + (b.b - a.b) * t,
      a: a.a + (b.a - a.a) * t
    };
  }

  // initialize blobs
  function initBlob(blob) {
    const vw = window.innerWidth;
    const vh = window.innerHeight;
    // position blobs roughly centered, scattered within a 400px radius circle in center
    const angle = Math.random() * Math.PI * 2;
    const radius = Math.random() * 200;
    blob._pos = {
      x: vw / 2 + Math.cos(angle) * radius,
      y: vh / 2 + Math.sin(angle) * radius
    };
    blob._vel = {
      x: (Math.random() - 0.5) * 0.6,
      y: (Math.random() - 0.5) * 0.6
    };
    blob._timeOffset = Math.random() * Math.PI * 2;
    blob._opacityBase = 0.14 + Math.random() * 0.06;
    blob._opacityDir = 1;

    // color lerp state
    blob._colorCurrent = randomRGBA();
    blob._colorTarget = randomRGBA();
    blob.style.backgroundColor = rgbaToString(blob._colorCurrent);
    blob._colorLerpT = 0;
    blob._colorLerpSpeed = 0.002 + Math.random() * 0.003;
  }

  blobs.forEach(initBlob);

  function clamp(v, min, max) { return Math.min(max, Math.max(min, v)); }

  function updateBorderRadius(blob, xRatio, yRatio, time) {
    const baseRadius = 50;
    const freq = 1.2;
    const amp = 15;
    const phase = blob._timeOffset;

    let tl = baseRadius + amp * Math.sin(freq * time + phase);
    let tr = baseRadius + amp * Math.sin(freq * time + phase + Math.PI/2);
    let br = baseRadius + amp * Math.sin(freq * time + phase + Math.PI);
    let bl = baseRadius + amp * Math.sin(freq * time + phase + 3*Math.PI/2);

    const pullStrength = 12;
    tl += pullStrength * (-xRatio - yRatio);
    tr += pullStrength * (xRatio - yRatio);
    br += pullStrength * (xRatio + yRatio);
    bl += pullStrength * (-xRatio + yRatio);

    tl = clamp(tl, 30, 80);
    tr = clamp(tr, 30, 80);
    br = clamp(br, 30, 80);
    bl = clamp(bl, 30, 80);

    blob.style.borderRadius = `${tl}% ${tr}% ${br}% ${bl}% / ${tl}% ${tr}% ${br}% ${bl}%`;
  }

  function updateOpacity(blob) {
    blob._opacityBase += 0.001 * blob._opacityDir;
    if(blob._opacityBase > 0.20) blob._opacityDir = -1;
    if(blob._opacityBase < 0.10) blob._opacityDir = 1;
    blob.style.opacity = blob._opacityBase.toFixed(3);
  }

  function attractBlobs(blob, others) {
    others.forEach(other => {
      if (other === blob) return;

      let dx = other._pos.x - blob._pos.x;
      let dy = other._pos.y - blob._pos.y;
      let dist = Math.sqrt(dx*dx + dy*dy);

      if(dist < maxDist) {
        let force = (maxDist - dist) / maxDist * 0.04;
        blob._vel.x += force * (dx / dist);
        blob._vel.y += force * (dy / dist);
      }
    });

    blob._vel.x *= 0.92;
    blob._vel.y *= 0.92;
  }

  // update colors gradually
  function updateColor(blob) {
    blob._colorLerpT += blob._colorLerpSpeed;
    if(blob._colorLerpT >= 1) {
      blob._colorLerpT = 0;
      blob._colorCurrent = blob._colorTarget;
      blob._colorTarget = randomRGBA();
    }
    const col = lerpColor(blob._colorCurrent, blob._colorTarget, blob._colorLerpT);
    blob.style.backgroundColor = rgbaToString(col);
  }

  // background canvas setup
  const canvas = document.getElementById('bgCanvas');
  const ctx = canvas.getContext('2d');

  function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  }
  window.addEventListener('resize', () => {
    resizeCanvas();
    // on resize reposition blobs with same logic so they don't cluster corners
    blobs.forEach(initBlob);
  });
  resizeCanvas();

  let time = 0;

  function drawBackground() {
    const w = canvas.width;
    const h = canvas.height;

    const cx = w / 2;
    const cy = h / 2;

    const radiusInner = 300;
    const radiusOuter = 1200;

    const gradient = ctx.createRadialGradient(cx, cy, radiusInner, cx, cy, radiusOuter);
    gradient.addColorStop(0, 'rgba(50, 75, 90, 0.3)');  // dimmer background now
    gradient.addColorStop(0.5, 'rgba(30, 45, 55, 0.15)');
    gradient.addColorStop(1, 'rgba(10, 15, 20, 0.4)');

    ctx.clearRect(0, 0, w, h);
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, w, h);
  }

  window._mouseX = window.innerWidth / 2;
  window._mouseY = window.innerHeight / 2;
  window.addEventListener('mousemove', e => {
    window._mouseX = e.clientX;
    window._mouseY = e.clientY;
  });

  function animate() {
    time += 0.02;

    blobs.forEach(blob => {
      attractBlobs(blob, blobs);

      blob._pos.x += blob._vel.x;
      blob._pos.y += blob._vel.y;

      if(blob._pos.x < 0) { blob._pos.x = 0; blob._vel.x *= -0.8; }
      if(blob._pos.x > window.innerWidth) { blob._pos.x = window.innerWidth; blob._vel.x *= -0.8; }
      if(blob._pos.y < 0) { blob._pos.y = 0; blob._vel.y *= -0.8; }
      if(blob._pos.y > window.innerHeight) { blob._pos.y = window.innerHeight; blob._vel.y *= -0.8; }

      blob.style.left = `${blob._pos.x}px`;
      blob.style.top = `${blob._pos.y}px`;

      const rect = blob.getBoundingClientRect();
      const blobCenterX = rect.left + rect.width / 2;
      const blobCenterY = rect.top + rect.height / 2;

      const mouseX = window._mouseX;
      const mouseY = window._mouseY;

      let xDiff = mouseX - blobCenterX;
      let yDiff = mouseY - blobCenterY;

      let xRatio = clamp(xDiff / maxDist, -1, 1);
      let yRatio = clamp(yDiff / maxDist, -1, 1);

      updateBorderRadius(blob, xRatio, yRatio, time);
      updateOpacity(blob);
      updateColor(blob);
    });

    drawBackground();

    requestAnimationFrame(animate);
  }

  blobs.forEach(blob => {
    blob.addEventListener('click', () => {
      blob._timeOffset = Math.random() * Math.PI * 2;
      blob._colorCurrent = randomRGBA();
      blob._colorTarget = randomRGBA();
      blob._colorLerpT = 0;
      blob.style.backgroundColor = rgbaToString(blob._colorCurrent);
      blob._opacityBase = 0.2;
      blob._opacityDir = -1;
    });
  });

  animate();
</script>
</body>
</html>
